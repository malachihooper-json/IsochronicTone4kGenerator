# Architecture & DSP Logic

This document covers the internal logic of how we generate isochronic pulses. Unlike binaural beats which need stereo separation, isochronic tones work monaurally through rapid amplitude shifts.

## The Synthesis Path

The core synthesis happens in the `PluginProcessor` class and the `BatchGenerator` utility. We keep it simple:

1.  **Phase Tracking**: We use a phasor to keep track of where we are in the carrier wave's cycle.
2.  **Volume Envelope**: An LFO or pulse-width modulated signal determines the current gain level.
3.  **Smoothing**: Hard square waves produce nasty transients. We apply a "softness" parameter to smooth out the pulse edges, making the listening experience less jarring.
4.  **Signal Normalization**: We keep the peaks between -0.1 and -3.0 dB to prevent digital clipping while maintaining high output volume.

## Orchestration

The shell scripts (`run.sh` and `master.sh`) act as the glue. They don't just run the binary; they handle the context:

*   **Logic mapping**: If the frequency is under 4Hz, the script automatically tags it as Delta. This saves time on manual tagging.
*   **External Integration**: The scripts coordinate FFmpeg to layer background audio or branding over the raw tones generated by the C++ engine.

## Performance Notes

We avoid any memory allocation in the audio thread. Everything is pre-allocated during the `prepareToPlay` stage. This keeps the processing glitch-free, even under heavy CPU loads. We also use JUCE's optimized buffers to handle SIMD processing where the hardware supports it.
